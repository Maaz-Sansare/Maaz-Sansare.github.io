<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mcal: I2C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Mcal
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__pcf__mcal__peripherals__i2c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">I2C<div class="ingroups"><a class="el" href="group__pcf__mcal.html">Mcal</a> &raquo; <a class="el" href="group__pcf__mcal__peripherals.html">Peripherals</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>I2C reers to Inter-Integrated Circuit is a widely used serial communication protocol that allows microcontrollers to exchange data with various peripheral devices and sensors using a simple, two-wire interface.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2c_config__t.html">I2cConfig_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa1dc119040bd314bb8e3693f66c0f221"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gaa1dc119040bd314bb8e3693f66c0f221">PCF_ENTITY_TYPE_I2C</a>&#160;&#160;&#160;((uint32_t)(0x43433249))</td></tr>
<tr class="memdesc:gaa1dc119040bd314bb8e3693f66c0f221"><td class="mdescLeft">&#160;</td><td class="mdescRight">EntityType_t.id, corresponds to EntityType_t.name = "I2CC".  <br /></td></tr>
<tr class="separator:gaa1dc119040bd314bb8e3693f66c0f221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977c5b8304a7ddcaa807bf3adaabb113"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga977c5b8304a7ddcaa807bf3adaabb113">PCF_S_ARBLOST</a>&#160;&#160;&#160;(PCF_S_ERROR_BASE_UCODE + 1)</td></tr>
<tr class="separator:ga977c5b8304a7ddcaa807bf3adaabb113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27622fda797c5b9266301418ef1f0b36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga27622fda797c5b9266301418ef1f0b36">PCF_S_BERR</a>&#160;&#160;&#160;(<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga977c5b8304a7ddcaa807bf3adaabb113">PCF_S_ARBLOST</a> + 1)</td></tr>
<tr class="separator:ga27622fda797c5b9266301418ef1f0b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d5d591b5bf3a9e940ed1cc939d2081a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga2d5d591b5bf3a9e940ed1cc939d2081a">PCF_S_ACK_ERROR</a>&#160;&#160;&#160;(<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga27622fda797c5b9266301418ef1f0b36">PCF_S_BERR</a> + 1)</td></tr>
<tr class="separator:ga2d5d591b5bf3a9e940ed1cc939d2081a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaee23d039f86adf4750d452d11cf1c52e"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gaee23d039f86adf4750d452d11cf1c52e">pcf_I2c_getEntityType</a> (EntityType_t *const type)</td></tr>
<tr class="memdesc:gaee23d039f86adf4750d452d11cf1c52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is a class static function which returns EntityType_t  <br /></td></tr>
<tr class="separator:gaee23d039f86adf4750d452d11cf1c52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a4f4a62013ac15e8891cdc00f32b246"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8a4f4a62013ac15e8891cdc00f32b246">pcf_I2c_getTotal</a> (pcf_size_t *const count)</td></tr>
<tr class="memdesc:ga8a4f4a62013ac15e8891cdc00f32b246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of I2C interfaces supported by the microcontroller.  <br /></td></tr>
<tr class="separator:ga8a4f4a62013ac15e8891cdc00f32b246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c060a4002bf1669ec7cc01b559cdc4b"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga5c060a4002bf1669ec7cc01b559cdc4b">pcf_I2c_getAvailable</a> (pcf_size_t *const count)</td></tr>
<tr class="memdesc:ga5c060a4002bf1669ec7cc01b559cdc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of available/unused I2C.  <br /></td></tr>
<tr class="separator:ga5c060a4002bf1669ec7cc01b559cdc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694da9f4314d87de95737ad389832a5b"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga694da9f4314d87de95737ad389832a5b">pcf_I2c_new</a> (const <a class="el" href="struct_i2c_config__t.html">I2cConfig_t</a> *const config, pcf_status_t *const status)</td></tr>
<tr class="memdesc:ga694da9f4314d87de95737ad389832a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance of <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> based on the configuration provided by <a class="el" href="struct_i2c_config__t.html">I2cConfig_t</a> <em>config</em> .  <br /></td></tr>
<tr class="separator:ga694da9f4314d87de95737ad389832a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a560c8438f0ca75ebd7c66fbb9a5af6"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga5a560c8438f0ca75ebd7c66fbb9a5af6">pcf_I2c_delete</a> (<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> **i2c)</td></tr>
<tr class="memdesc:ga5a560c8438f0ca75ebd7c66fbb9a5af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes/destroys <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity returned from <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga694da9f4314d87de95737ad389832a5b" title="Creates a new instance of I2c_t based on the configuration provided by I2cConfig_t config .">pcf_I2c_new</a>.  <br /></td></tr>
<tr class="separator:ga5a560c8438f0ca75ebd7c66fbb9a5af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae731ce14c57884c6c7aaf381ec382a09"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gae731ce14c57884c6c7aaf381ec382a09">pcf_I2c_setPriority</a> (const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, const <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a> tx_priority, const <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a> tx_sub_priority, const <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a> rx_priority, const <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a> rx_sub_priority)</td></tr>
<tr class="memdesc:gae731ce14c57884c6c7aaf381ec382a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Tx and Rx interrupt priority of a particular <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> object depending on mode of i2c's Tx and Rx.  <br /></td></tr>
<tr class="separator:gae731ce14c57884c6c7aaf381ec382a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a6f1c47b9d44daf6579816c6b8f4523"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga6a6f1c47b9d44daf6579816c6b8f4523">pcf_I2c_getPriority</a> (const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a> *const tx_priority, <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a> *const tx_sub_priority, <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a> *const rx_priority, <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a> *const rx_sub_priority)</td></tr>
<tr class="memdesc:ga6a6f1c47b9d44daf6579816c6b8f4523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Tx and Rx interrupt priority of a particular <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> object depending on mode of i2c's Tx and Rx.  <br /></td></tr>
<tr class="separator:ga6a6f1c47b9d44daf6579816c6b8f4523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6bed523fe7128453473405e88ecf7ed"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gab6bed523fe7128453473405e88ecf7ed">pcf_I2c_enable</a> (<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, const EnPCFBoolean_t enable)</td></tr>
<tr class="memdesc:gab6bed523fe7128453473405e88ecf7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/Disables the specified I2C.  <br /></td></tr>
<tr class="separator:gab6bed523fe7128453473405e88ecf7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga157514c2ace00a2e689e5cab6d8db9cd"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga157514c2ace00a2e689e5cab6d8db9cd">pcf_I2c_masterWrite</a> (<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, const uint16_t slave_address, const Buffer_t *const buffer, const uint32_t timeout_ms)</td></tr>
<tr class="memdesc:ga157514c2ace00a2e689e5cab6d8db9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a master write operation on the I2C bus by sending data to a slave device.  <br /></td></tr>
<tr class="separator:ga157514c2ace00a2e689e5cab6d8db9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga083039467dc9565ff7bcf86daba9fed2"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga083039467dc9565ff7bcf86daba9fed2">pcf_I2c_masterWriteReg</a> (<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, const uint16_t slave_address, const pcf_byte_t reg, const Buffer_t *const buffer, const uint32_t timeout_ms)</td></tr>
<tr class="memdesc:ga083039467dc9565ff7bcf86daba9fed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a master write register operation on the I2C bus by sending data to a slave device at the specified register address.  <br /></td></tr>
<tr class="separator:ga083039467dc9565ff7bcf86daba9fed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f2b83e3303125b37248594e4b8760b"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga78f2b83e3303125b37248594e4b8760b">pcf_I2c_masterRead</a> (<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, const uint16_t slave_address, Buffer_t *const buffer, const uint32_t timeout_ms)</td></tr>
<tr class="memdesc:ga78f2b83e3303125b37248594e4b8760b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a master read operation on the I2C bus by receiving data from a slave device.  <br /></td></tr>
<tr class="separator:ga78f2b83e3303125b37248594e4b8760b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e1a31ab9ea7bf5fae4a9c633e05f494"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga9e1a31ab9ea7bf5fae4a9c633e05f494">pcf_I2c_masterReadReg</a> (<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, const uint16_t slave_address, const pcf_byte_t reg, Buffer_t *const data, const uint32_t timeout_ms)</td></tr>
<tr class="memdesc:ga9e1a31ab9ea7bf5fae4a9c633e05f494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a master read operation on the I2C bus by first sending a register address to the slave device, and then receiving data from the slave device.  <br /></td></tr>
<tr class="separator:ga9e1a31ab9ea7bf5fae4a9c633e05f494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9078ee50362867346d6b45013175310c"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga9078ee50362867346d6b45013175310c">pcf_I2c_slaveRead</a> (<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, Buffer_t *const buffer, pcf_size_t *const actual_size)</td></tr>
<tr class="memdesc:ga9078ee50362867346d6b45013175310c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a slave read operation on the I2C bus.  <br /></td></tr>
<tr class="separator:ga9078ee50362867346d6b45013175310c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf620553b53b08ec75b40d6580ccdf11"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gacf620553b53b08ec75b40d6580ccdf11">pcf_I2c_slaveWrite</a> (<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, const Buffer_t *const buffer, pcf_size_t *const actual_size)</td></tr>
<tr class="memdesc:gacf620553b53b08ec75b40d6580ccdf11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a slave write operation on the I2C bus.  <br /></td></tr>
<tr class="separator:gacf620553b53b08ec75b40d6580ccdf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab862e0b636c160d768365e9ba1f97800"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gab862e0b636c160d768365e9ba1f97800">pcf_I2c_slaveReceivedRequest</a> (const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, <a class="el" href="group__pcf__mcal__peripherals__i2c.html#gac449d24faad23209d50113c27a6e01e1">EnI2cSlaveRequestType_t</a> *const type)</td></tr>
<tr class="memdesc:gab862e0b636c160d768365e9ba1f97800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the request received by slave from the master.  <br /></td></tr>
<tr class="separator:gab862e0b636c160d768365e9ba1f97800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf92e2cabb6c31c4b7c123b469ceb9e53"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gaf92e2cabb6c31c4b7c123b469ceb9e53">pcf_I2c_isBusy</a> (const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, EnPCFBoolean_t *const isBusy)</td></tr>
<tr class="memdesc:gaf92e2cabb6c31c4b7c123b469ceb9e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the i2c bus is busy.  <br /></td></tr>
<tr class="separator:gaf92e2cabb6c31c4b7c123b469ceb9e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga082c04b9ee95ad97a377647fa576807a"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga082c04b9ee95ad97a377647fa576807a">pcf_I2c_getRxDataAvailable</a> (const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, pcf_size_t *const count)</td></tr>
<tr class="memdesc:ga082c04b9ee95ad97a377647fa576807a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of bytes received in i2c receive buffer.  <br /></td></tr>
<tr class="separator:ga082c04b9ee95ad97a377647fa576807a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d93848553469264f26d4a8b4195094"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga25d93848553469264f26d4a8b4195094">pcf_I2c_rxBufferFlush</a> (<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c)</td></tr>
<tr class="memdesc:ga25d93848553469264f26d4a8b4195094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush I2c rx buffer.  <br /></td></tr>
<tr class="separator:ga25d93848553469264f26d4a8b4195094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa22722773b41444ba2128da7cd35333f"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gaa22722773b41444ba2128da7cd35333f">pcf_I2c_txBufferFlush</a> (<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c)</td></tr>
<tr class="memdesc:gaa22722773b41444ba2128da7cd35333f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush I2c tx buffer.  <br /></td></tr>
<tr class="separator:gaa22722773b41444ba2128da7cd35333f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5524b9c476b70008fa3b79012597304"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gad5524b9c476b70008fa3b79012597304">pcf_I2c_getId</a> (const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, pcf_size_t *const id)</td></tr>
<tr class="memdesc:gad5524b9c476b70008fa3b79012597304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <em>id</em>  of given I2c object.  <br /></td></tr>
<tr class="separator:gad5524b9c476b70008fa3b79012597304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga141b8a97b1079ca81a5de159a334ae45"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga141b8a97b1079ca81a5de159a334ae45">pcf_I2c_getBaudrate</a> (const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, <a class="el" href="struct_frequency__t.html">Frequency_t</a> *const baud_rate)</td></tr>
<tr class="memdesc:ga141b8a97b1079ca81a5de159a334ae45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the baudrate set for I2c.  <br /></td></tr>
<tr class="separator:ga141b8a97b1079ca81a5de159a334ae45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec7f1ee6d132db8d39ea3044b1bc447"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga6ec7f1ee6d132db8d39ea3044b1bc447">pcf_I2c_getAddress</a> (const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, uint16_t *const address)</td></tr>
<tr class="memdesc:ga6ec7f1ee6d132db8d39ea3044b1bc447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the own address set for I2c.  <br /></td></tr>
<tr class="separator:ga6ec7f1ee6d132db8d39ea3044b1bc447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf25d28290bf27133269753f8fc62d6"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga1cf25d28290bf27133269753f8fc62d6">pcf_I2c_getAddressMask</a> (const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, uint16_t *const address_mask)</td></tr>
<tr class="memdesc:ga1cf25d28290bf27133269753f8fc62d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the own address mask set for I2c.  <br /></td></tr>
<tr class="separator:ga1cf25d28290bf27133269753f8fc62d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga559ac4b618aec28688ff479e0f86ff53"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga559ac4b618aec28688ff479e0f86ff53">pcf_I2c_isGeneralCallEnabled</a> (const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, EnPCFBoolean_t *const isEnabled)</td></tr>
<tr class="memdesc:ga559ac4b618aec28688ff479e0f86ff53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if GeneralCall is enabled.  <br /></td></tr>
<tr class="separator:ga559ac4b618aec28688ff479e0f86ff53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga775a4e80f922e06d110b5783a3616e50"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga775a4e80f922e06d110b5783a3616e50">pcf_I2c_getRxBufferSize</a> (const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, pcf_size_t *const size)</td></tr>
<tr class="memdesc:ga775a4e80f922e06d110b5783a3616e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of I2c receive buffer.  <br /></td></tr>
<tr class="separator:ga775a4e80f922e06d110b5783a3616e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22091654e56ea13f98a12b2548945132"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga22091654e56ea13f98a12b2548945132">pcf_I2c_getTxBufferSize</a> (const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const i2c, pcf_size_t *const size)</td></tr>
<tr class="memdesc:ga22091654e56ea13f98a12b2548945132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of I2c transmit buffer.  <br /></td></tr>
<tr class="separator:ga22091654e56ea13f98a12b2548945132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9aa76cde12a0f4d83e4b8dedfc80116"><td class="memItemLeft" align="right" valign="top">PCF_MCAL_API pcf_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gab9aa76cde12a0f4d83e4b8dedfc80116">pcf_I2c_customCommand</a> (const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const I2c, const pcf_command_t command, pcf_generic_t data)</td></tr>
<tr class="memdesc:gab9aa76cde12a0f4d83e4b8dedfc80116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be used to extend the functionality provided by the I2C package item.  <br /></td></tr>
<tr class="separator:gab9aa76cde12a0f4d83e4b8dedfc80116"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga529397d7a798fee26f1872ec238f0041"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga529397d7a798fee26f1872ec238f0041">I2cConfig_t::id</a></td></tr>
<tr class="separator:ga529397d7a798fee26f1872ec238f0041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9112274d274b9da9211e70f7a500fc1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gab9112274d274b9da9211e70f7a500fc1">I2cConfig_t::baudrate</a></td></tr>
<tr class="separator:gab9112274d274b9da9211e70f7a500fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bbace4037550379597e998a7f582529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga4dc94555d8d00ba1f70bc4caeec91d88">EnI2cAddressType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga2bbace4037550379597e998a7f582529">I2cConfig_t::addressType</a></td></tr>
<tr class="separator:ga2bbace4037550379597e998a7f582529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac759f54ef1325767a83a9bbdbed790"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga0ac759f54ef1325767a83a9bbdbed790">I2cConfig_t::ownAddress</a></td></tr>
<tr class="separator:ga0ac759f54ef1325767a83a9bbdbed790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3785e7bc0bf5e4b4181c5df242e3d702"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga3785e7bc0bf5e4b4181c5df242e3d702">I2cConfig_t::ownAddressMask</a></td></tr>
<tr class="separator:ga3785e7bc0bf5e4b4181c5df242e3d702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaebbfc2e6dfa1c3ee12df6d458d2f7e"><td class="memItemLeft" align="right" valign="top">EnPCFBoolean_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gafaebbfc2e6dfa1c3ee12df6d458d2f7e">I2cConfig_t::generalCallEnable</a></td></tr>
<tr class="separator:gafaebbfc2e6dfa1c3ee12df6d458d2f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe7f46a24307e2f158bc087f2082311b"><td class="memItemLeft" align="right" valign="top">pcf_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gafe7f46a24307e2f158bc087f2082311b">I2cConfig_t::txBufferSize</a></td></tr>
<tr class="separator:gafe7f46a24307e2f158bc087f2082311b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae80263dd6717b8b5a43094f5d8f56e7a"><td class="memItemLeft" align="right" valign="top">pcf_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gae80263dd6717b8b5a43094f5d8f56e7a">I2cConfig_t::rxBufferSize</a></td></tr>
<tr class="separator:gae80263dd6717b8b5a43094f5d8f56e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c0e1653d9895946855bcb907db0a252"><td class="memItemLeft" align="right" valign="top">pcf_generic_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga3c0e1653d9895946855bcb907db0a252">I2cConfig_t::hardwareCfg</a></td></tr>
<tr class="separator:ga3c0e1653d9895946855bcb907db0a252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">I2C types</h2></td></tr>
<tr class="memitem:ga4dc94555d8d00ba1f70bc4caeec91d88"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga4dc94555d8d00ba1f70bc4caeec91d88">EnI2cAddressType_t</a> { <a class="el" href="group__pcf__mcal__peripherals__i2c.html#gga4dc94555d8d00ba1f70bc4caeec91d88ad8cb2df8f2b6ac5df2cbc1a5d912cb89">enI2cAddress_7bit</a>
, <a class="el" href="group__pcf__mcal__peripherals__i2c.html#gga4dc94555d8d00ba1f70bc4caeec91d88afe615a9575e7f206c9f73b692026667d">enI2cAddress_10bit</a>
 }</td></tr>
<tr class="memdesc:ga4dc94555d8d00ba1f70bc4caeec91d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C address type.  <a href="group__pcf__mcal__peripherals__i2c.html#ga4dc94555d8d00ba1f70bc4caeec91d88">More...</a><br /></td></tr>
<tr class="separator:ga4dc94555d8d00ba1f70bc4caeec91d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac449d24faad23209d50113c27a6e01e1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gac449d24faad23209d50113c27a6e01e1">EnI2cSlaveRequestType_t</a> { <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ggac449d24faad23209d50113c27a6e01e1a6ec7b0ecb7a85445c2cdb1fe526a4a94">enI2cSlaveRequestType_None</a> = 0
, <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ggac449d24faad23209d50113c27a6e01e1a9847936c9ab2786b558131e7886f5c35">enI2cSlaveRequestType_Write</a>
, <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ggac449d24faad23209d50113c27a6e01e1aca3f1ed9991e10234f6d97cbb0111f58">enI2cSlaveRequestType_Read</a>
, <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ggac449d24faad23209d50113c27a6e01e1af9c7452bb8aac3aa7258664917e7447d">enI2cSlaveRequestType_ReadGeneral</a>
 }</td></tr>
<tr class="memdesc:gac449d24faad23209d50113c27a6e01e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C slave request type.  <a href="group__pcf__mcal__peripherals__i2c.html#gac449d24faad23209d50113c27a6e01e1">More...</a><br /></td></tr>
<tr class="separator:gac449d24faad23209d50113c27a6e01e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd8e4fab7d6b537d91df518e7d3aeea"><td class="memItemLeft" align="right" valign="top">typedef struct _pcf_communication_i2c_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a></td></tr>
<tr class="memdesc:ga8fd8e4fab7d6b537d91df518e7d3aeea"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Entity object.  <br /></td></tr>
<tr class="separator:ga8fd8e4fab7d6b537d91df518e7d3aeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>I2C reers to Inter-Integrated Circuit is a widely used serial communication protocol that allows microcontrollers to exchange data with various peripheral devices and sensors using a simple, two-wire interface. </p>
<p>It is commonly employed for connecting sensors, EEPROMs, LCD displays, and other integrated circuits in embedded systems. </p><dl class="section note"><dt>Note</dt><dd>Input validation is done only when package is built in debug mode. <br  />
 </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa1dc119040bd314bb8e3693f66c0f221" name="gaa1dc119040bd314bb8e3693f66c0f221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1dc119040bd314bb8e3693f66c0f221">&#9670;&#160;</a></span>PCF_ENTITY_TYPE_I2C</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCF_ENTITY_TYPE_I2C&#160;&#160;&#160;((uint32_t)(0x43433249))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EntityType_t.id, corresponds to EntityType_t.name = "I2CC". </p>

</div>
</div>
<a id="ga977c5b8304a7ddcaa807bf3adaabb113" name="ga977c5b8304a7ddcaa807bf3adaabb113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga977c5b8304a7ddcaa807bf3adaabb113">&#9670;&#160;</a></span>PCF_S_ARBLOST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCF_S_ARBLOST&#160;&#160;&#160;(PCF_S_ERROR_BASE_UCODE + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga27622fda797c5b9266301418ef1f0b36" name="ga27622fda797c5b9266301418ef1f0b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27622fda797c5b9266301418ef1f0b36">&#9670;&#160;</a></span>PCF_S_BERR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCF_S_BERR&#160;&#160;&#160;(<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga977c5b8304a7ddcaa807bf3adaabb113">PCF_S_ARBLOST</a> + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga2d5d591b5bf3a9e940ed1cc939d2081a" name="ga2d5d591b5bf3a9e940ed1cc939d2081a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d5d591b5bf3a9e940ed1cc939d2081a">&#9670;&#160;</a></span>PCF_S_ACK_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCF_S_ACK_ERROR&#160;&#160;&#160;(<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga27622fda797c5b9266301418ef1f0b36">PCF_S_BERR</a> + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga8fd8e4fab7d6b537d91df518e7d3aeea" name="ga8fd8e4fab7d6b537d91df518e7d3aeea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fd8e4fab7d6b537d91df518e7d3aeea">&#9670;&#160;</a></span>I2c_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _pcf_communication_i2c_t <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C Entity object. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga4dc94555d8d00ba1f70bc4caeec91d88" name="ga4dc94555d8d00ba1f70bc4caeec91d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dc94555d8d00ba1f70bc4caeec91d88">&#9670;&#160;</a></span>EnI2cAddressType_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga4dc94555d8d00ba1f70bc4caeec91d88">EnI2cAddressType_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C address type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4dc94555d8d00ba1f70bc4caeec91d88ad8cb2df8f2b6ac5df2cbc1a5d912cb89" name="gga4dc94555d8d00ba1f70bc4caeec91d88ad8cb2df8f2b6ac5df2cbc1a5d912cb89"></a>enI2cAddress_7bit&#160;</td><td class="fielddoc"><p>7bit address type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4dc94555d8d00ba1f70bc4caeec91d88afe615a9575e7f206c9f73b692026667d" name="gga4dc94555d8d00ba1f70bc4caeec91d88afe615a9575e7f206c9f73b692026667d"></a>enI2cAddress_10bit&#160;</td><td class="fielddoc"><p>10bit address type </p>
</td></tr>
</table>

</div>
</div>
<a id="gac449d24faad23209d50113c27a6e01e1" name="gac449d24faad23209d50113c27a6e01e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac449d24faad23209d50113c27a6e01e1">&#9670;&#160;</a></span>EnI2cSlaveRequestType_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__pcf__mcal__peripherals__i2c.html#gac449d24faad23209d50113c27a6e01e1">EnI2cSlaveRequestType_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C slave request type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac449d24faad23209d50113c27a6e01e1a6ec7b0ecb7a85445c2cdb1fe526a4a94" name="ggac449d24faad23209d50113c27a6e01e1a6ec7b0ecb7a85445c2cdb1fe526a4a94"></a>enI2cSlaveRequestType_None&#160;</td><td class="fielddoc"><p>No Request made to slave </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac449d24faad23209d50113c27a6e01e1a9847936c9ab2786b558131e7886f5c35" name="ggac449d24faad23209d50113c27a6e01e1a9847936c9ab2786b558131e7886f5c35"></a>enI2cSlaveRequestType_Write&#160;</td><td class="fielddoc"><p>Slave is requested to write/send data to master </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac449d24faad23209d50113c27a6e01e1aca3f1ed9991e10234f6d97cbb0111f58" name="ggac449d24faad23209d50113c27a6e01e1aca3f1ed9991e10234f6d97cbb0111f58"></a>enI2cSlaveRequestType_Read&#160;</td><td class="fielddoc"><p>Slave is requested to read/receive data sent from master </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac449d24faad23209d50113c27a6e01e1af9c7452bb8aac3aa7258664917e7447d" name="ggac449d24faad23209d50113c27a6e01e1af9c7452bb8aac3aa7258664917e7447d"></a>enI2cSlaveRequestType_ReadGeneral&#160;</td><td class="fielddoc"><p>Slave is requested to read/receive data sent from master on General Address </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaee23d039f86adf4750d452d11cf1c52e" name="gaee23d039f86adf4750d452d11cf1c52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee23d039f86adf4750d452d11cf1c52e">&#9670;&#160;</a></span>pcf_I2c_getEntityType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_getEntityType </td>
          <td>(</td>
          <td class="paramtype">EntityType_t *const&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is a class static function which returns EntityType_t </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>[OUT] - Pointer to EntityType_t, stores the entity type of the I2C. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>type</em>  is PCF_NULL. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8a4f4a62013ac15e8891cdc00f32b246" name="ga8a4f4a62013ac15e8891cdc00f32b246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a4f4a62013ac15e8891cdc00f32b246">&#9670;&#160;</a></span>pcf_I2c_getTotal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_getTotal </td>
          <td>(</td>
          <td class="paramtype">pcf_size_t *const&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the total number of I2C interfaces supported by the microcontroller. </p>
<p><br  />
 The value returned will be same throughout runtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>[OUT] - Pointer to pcf_size_t, stores the total number of I2C interfaces available </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>count</em>  is PCF_NULL. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5c060a4002bf1669ec7cc01b559cdc4b" name="ga5c060a4002bf1669ec7cc01b559cdc4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c060a4002bf1669ec7cc01b559cdc4b">&#9670;&#160;</a></span>pcf_I2c_getAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_getAvailable </td>
          <td>(</td>
          <td class="paramtype">pcf_size_t *const&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of available/unused I2C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>[OUT] - Pointer to pcf_size_t, stores the number of available/unused I2Cs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>count</em>  is PCF_NULL. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga694da9f4314d87de95737ad389832a5b" name="ga694da9f4314d87de95737ad389832a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga694da9f4314d87de95737ad389832a5b">&#9670;&#160;</a></span>pcf_I2c_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> * pcf_I2c_new </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_i2c_config__t.html">I2cConfig_t</a> *const&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcf_status_t *const&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new instance of <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> based on the configuration provided by <a class="el" href="struct_i2c_config__t.html">I2cConfig_t</a> <em>config</em> . </p>
<dl class="section note"><dt>Note</dt><dd>If txBufferSize or rxBufferSize is set to zero the respective process will operate in blocking/polling mode else in non-blocking mode. </dd>
<dd>
By default we try to use DMA for communication. However, in cases where all DMA channels are busy or if DMA is not available, the process will fallback to interrupt mode for data transfer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>[IN] - Pointer to the i2c configuration structure <a class="el" href="struct_i2c_config__t.html">I2cConfig_t</a>. </td></tr>
    <tr><td class="paramname">status</td><td>[OUT] - Pointer to pcf_status_t, stores the status of the function call. <br  />
 (Optional parameter, pass PCF_NULL if not required.) <br  />
 Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>config</em>  or config.hardwareCfg is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : config.id or config.baudrate is invalid. (Checked only in debug mode) </li>
<li>
PCF_S_ALREADY_IN_USE : I2C id is already in used or the mcu pin is already in use. </li>
<li>
PCF_S_NOT_ENOUGH_MEMORY : Not enough memory to create the I2c entity. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>valid values: <ul>
<li>
On success - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a>.  </li>
<li>
On failure - PCF_NULL.  </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5a560c8438f0ca75ebd7c66fbb9a5af6" name="ga5a560c8438f0ca75ebd7c66fbb9a5af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a560c8438f0ca75ebd7c66fbb9a5af6">&#9670;&#160;</a></span>pcf_I2c_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> **&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes/destroys <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity returned from <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga694da9f4314d87de95737ad389832a5b" title="Creates a new instance of I2c_t based on the configuration provided by I2cConfig_t config .">pcf_I2c_new</a>. </p>
<p><br  />
 <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity cannot be used after a call to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Double A pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS  : On success. </li>
<li>
PCF_S_NULL_ARG  : <em>i2c</em>  or <em>*i2c</em>  is passed.(Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG  : <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> is invalid.(Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae731ce14c57884c6c7aaf381ec382a09" name="gae731ce14c57884c6c7aaf381ec382a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae731ce14c57884c6c7aaf381ec382a09">&#9670;&#160;</a></span>pcf_I2c_setPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_setPriority </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a>&#160;</td>
          <td class="paramname"><em>tx_priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a>&#160;</td>
          <td class="paramname"><em>tx_sub_priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a>&#160;</td>
          <td class="paramname"><em>rx_priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a>&#160;</td>
          <td class="paramname"><em>rx_sub_priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Tx and Rx interrupt priority of a particular <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> object depending on mode of i2c's Tx and Rx. </p>
<dl class="section note"><dt>Note</dt><dd>i2c Tx can be either in DMA,INT or POL mode. </dd>
<dd>
i2c Rx can be either in DMA,INT or POL mode. </dd>
<dd>
The mode of i2c is decided via config at time of creation of <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> object using pcf_Spi_new.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - A pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> object. </td></tr>
    <tr><td class="paramname">tx_priority</td><td>[IN] - NVIC priority level for i2c Tx, lower value indicates higher priority </td></tr>
    <tr><td class="paramname">tx_sub_priority</td><td>[IN] - NVIC sub-priority level for i2c Tx, lower value indicates higher sub-priority </td></tr>
    <tr><td class="paramname">rx_priority</td><td>[IN] - NVIC priority level for i2c Rx, lower value indicates higher priority </td></tr>
    <tr><td class="paramname">rx_sub_priority</td><td>[IN] - NVIC sub-priority level for i2c Rx, lower value indicates higher sub-priority </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCFS_SUCCESS  : On success. </li>
<li>
PCFS_NULL_ARG  : <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> object is passed.(Checked only in debug mode) </li>
<li>
PCFS_INVALID_ARG  : Invalid <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> object is passed.(Checked only in debug mode) </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If Tx and Rx both are in INT mode, then only <em>rx_priority</em>  and <em>rx_sub_priority</em>  are taken into consideration while setting the priority. </dd></dl>

</div>
</div>
<a id="ga6a6f1c47b9d44daf6579816c6b8f4523" name="ga6a6f1c47b9d44daf6579816c6b8f4523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a6f1c47b9d44daf6579816c6b8f4523">&#9670;&#160;</a></span>pcf_I2c_getPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_getPriority </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a> *const&#160;</td>
          <td class="paramname"><em>tx_priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a> *const&#160;</td>
          <td class="paramname"><em>tx_sub_priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a> *const&#160;</td>
          <td class="paramname"><em>rx_priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63">interrupt_t</a> *const&#160;</td>
          <td class="paramname"><em>rx_sub_priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Tx and Rx interrupt priority of a particular <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> object depending on mode of i2c's Tx and Rx. </p>
<dl class="section note"><dt>Note</dt><dd>i2c Tx can be either in DMA,INT or POL mode. </dd>
<dd>
i2c Rx can be either in DMA,INT or POL mode. </dd>
<dd>
The mode of i2c is decided via config at time of creation of <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> object using pcf_Spi_new. &lt;/summary</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - A pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> object. </td></tr>
    <tr><td class="paramname">tx_priority</td><td>[OUT] - Pointer to <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63" title="Interrupt type.">interrupt_t</a>, stores the priority of the tx. lower value indicates higher priority. </td></tr>
    <tr><td class="paramname">tx_sub_priority</td><td>[OUT] - Pointer to <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63" title="Interrupt type.">interrupt_t</a>, stores the sub priority of the tx. lower value indicates higher sub-priority. </td></tr>
    <tr><td class="paramname">rx_priority</td><td>[OUT] - Pointer to <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63" title="Interrupt type.">interrupt_t</a>, stores the priority of the rx. lower value indicates higher priority. </td></tr>
    <tr><td class="paramname">rx_sub_priority</td><td>[OUT] - Pointer to <a class="el" href="group__pcf__mcal__interrupt__controller.html#ga45b61ed9b8f6821af8b5ee26603bcb63" title="Interrupt type.">interrupt_t</a>, stores the sub priority of the rx. lower value indicates higher sub-priority. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS  : On success. </li>
<li>
PCF_S_NULL_ARG  : <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> object or <em>tx_priority</em>  or <em>tx_sub_priority</em>  or <em>rx_priority</em>  or <em>rx_sub_priority</em>  is PCF_NULL.(Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG  : Invalid <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> object is passed.(Checked only in debug mode) </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If i2c Tx and Rx both are in INT mode, then values of <em>tx_priority</em>  and <em>tx_sub_priority</em>  will be same as values of <em>rx_priority</em>  and <em>rx_sub_priority</em>  respectively, since only the values of <em>rx_priority</em>  and <em>rx_sub_priority</em>  are taken into consideration while getting the priority. </dd></dl>

</div>
</div>
<a id="gab6bed523fe7128453473405e88ecf7ed" name="gab6bed523fe7128453473405e88ecf7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6bed523fe7128453473405e88ecf7ed">&#9670;&#160;</a></span>pcf_I2c_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EnPCFBoolean_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/Disables the specified I2C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">enable</td><td>[IN] - <em>i2c</em>  is enabled if EnPCFBoolean_t is enPCFBoolean_True or disabled if enPCFBoolean_False </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga157514c2ace00a2e689e5cab6d8db9cd" name="ga157514c2ace00a2e689e5cab6d8db9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga157514c2ace00a2e689e5cab6d8db9cd">&#9670;&#160;</a></span>pcf_I2c_masterWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_masterWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>slave_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Buffer_t *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a master write operation on the I2C bus by sending data to a slave device. </p>
<p>Function will be blocked until all the data is sent or timeout has occurred.</p>
<p>If timeout is set to 0 this means no timeout and function will block till all data is sent or an error occurs.</p>
<p>Flow of data on I2C Bus: Start (Acquire bus) -&gt; Slave Address -&gt; R/W bit set to W -&gt; Data -&gt; NACK -&gt; STOP</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">slave_address</td><td>[IN] - Address of the slave. </td></tr>
    <tr><td class="paramname">buffer</td><td>[IN] - Pointer to the data buffer. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>[IN] - Timeout in ms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>data</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid or buffer.length is 0. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_OPERATION : Transfer cannot be stopped because of some ongoing operation. </li>
<li>
<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga977c5b8304a7ddcaa807bf3adaabb113">PCF_S_ARBLOST</a> : Arbitration lost. </li>
<li>
<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga27622fda797c5b9266301418ef1f0b36">PCF_S_BERR</a> : Bus error. </li>
<li>
<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga2d5d591b5bf3a9e940ed1cc939d2081a">PCF_S_ACK_ERROR</a> : Acknowledgment error occurred during the transfer. </li>
<li>
PCF_S_TIMEOUT : Operation Timed out. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga083039467dc9565ff7bcf86daba9fed2" name="ga083039467dc9565ff7bcf86daba9fed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga083039467dc9565ff7bcf86daba9fed2">&#9670;&#160;</a></span>pcf_I2c_masterWriteReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_masterWriteReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>slave_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pcf_byte_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Buffer_t *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a master write register operation on the I2C bus by sending data to a slave device at the specified register address. </p>
<p>The function will be blocked until all the data is sent or timeout has occurred.</p>
<p>Start -&gt; Slave Address -&gt; R/W bit set to W -&gt; Register address -&gt; Data -&gt; STOP</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">slave_address</td><td>[IN] - Address of the slave </td></tr>
    <tr><td class="paramname">reg</td><td>[IN] - Address of register on the slave to be written. </td></tr>
    <tr><td class="paramname">buffer</td><td>[IN] - Pointer to the data buffer </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>[IN] - Timeout in ms </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>data</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid or buffer.length is 0. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_OPERATION : Transfer cannot be stopped because of some ongoing operation. </li>
<li>
<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga977c5b8304a7ddcaa807bf3adaabb113">PCF_S_ARBLOST</a> : Arbitration lost. </li>
<li>
<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga27622fda797c5b9266301418ef1f0b36">PCF_S_BERR</a> : Bus error. </li>
<li>
<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga2d5d591b5bf3a9e940ed1cc939d2081a">PCF_S_ACK_ERROR</a> : Acknowledgment error occurred during the transfer. </li>
<li>
PCF_S_TIMEOUT : Operation Timed out. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga78f2b83e3303125b37248594e4b8760b" name="ga78f2b83e3303125b37248594e4b8760b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78f2b83e3303125b37248594e4b8760b">&#9670;&#160;</a></span>pcf_I2c_masterRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_masterRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>slave_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Buffer_t *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a master read operation on the I2C bus by receiving data from a slave device. </p>
<p><br  />
 The function will be block until all the data is read or a timeout occurrs.</p>
<p>Flow of data on I2C bus: Start -&gt; Slave Address -&gt; R/W bit set to R -&gt; Data from slave -&gt; NACK -&gt; STOP</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">slave_address</td><td>[IN] - Address of the slave </td></tr>
    <tr><td class="paramname">buffer</td><td>[OUT] - Pointer to pcf_byte_t, where data that is read will be copied </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>[IN] - Timeout in ms </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>data</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid or buffer.length is 0. (Checked only in debug mode) </li>
<li>
<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga977c5b8304a7ddcaa807bf3adaabb113">PCF_S_ARBLOST</a> : Arbitration lost. </li>
<li>
<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga27622fda797c5b9266301418ef1f0b36">PCF_S_BERR</a> : Bus error. </li>
<li>
<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga2d5d591b5bf3a9e940ed1cc939d2081a">PCF_S_ACK_ERROR</a> : Acknowledgment error occurred during the transfer. </li>
<li>
PCF_S_TIMEOUT : Operation Timed out. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9e1a31ab9ea7bf5fae4a9c633e05f494" name="ga9e1a31ab9ea7bf5fae4a9c633e05f494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e1a31ab9ea7bf5fae4a9c633e05f494">&#9670;&#160;</a></span>pcf_I2c_masterReadReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_masterReadReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>slave_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pcf_byte_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Buffer_t *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a master read operation on the I2C bus by first sending a register address to the slave device, and then receiving data from the slave device. </p>
<p>The function will be block until all the data is read or a timeout occurrs.</p>
<p>Flow of data on I2C bus: Start -&gt; Slave Address -&gt; R/W bit set to W -&gt; Register address -&gt; Start -&gt; Slave Address -&gt; R/W bit set to R -&gt; Data from slave -&gt; NACK -&gt; STOP</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">slave_address</td><td>[IN] - Address of the slave </td></tr>
    <tr><td class="paramname">reg</td><td>[IN] - Register address </td></tr>
    <tr><td class="paramname">data</td><td>[OUT] - Pointer to pcf_byte_t, where data that is read will be copied </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>[IN] - Timeout in ms </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>data</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid or buffer.length is 0. (Checked only in debug mode) </li>
<li>
<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga977c5b8304a7ddcaa807bf3adaabb113">PCF_S_ARBLOST</a> : Arbitration lost. </li>
<li>
<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga27622fda797c5b9266301418ef1f0b36">PCF_S_BERR</a> : Bus error. </li>
<li>
<a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga2d5d591b5bf3a9e940ed1cc939d2081a">PCF_S_ACK_ERROR</a> : Acknowledgment error occurred during the transfer. </li>
<li>
PCF_S_TIMEOUT : Operation Timed out. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9078ee50362867346d6b45013175310c" name="ga9078ee50362867346d6b45013175310c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9078ee50362867346d6b45013175310c">&#9670;&#160;</a></span>pcf_I2c_slaveRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_slaveRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Buffer_t *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcf_size_t *const&#160;</td>
          <td class="paramname"><em>actual_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a slave read operation on the I2C bus. </p>
<p>The slave can call this function once it receives a request from master to receive data. The caller can call <em>pcf_I2c_getRxDataAvailable()</em>  to check how much data is available for read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">buffer</td><td>[OUT] - Pointer to pcf_byte_t, where data that is read will be copied </td></tr>
    <tr><td class="paramname">actual_size</td><td>[OUT] - Pointer to pcf_size_t, stores the total number of bytes actually read </td></tr>
  </table>
  </dd>
</dl>
<p>(Optional parameter, pass PCF_NULL if not required.) <br  />
</p>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>data</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid or buffer.length is 0. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gacf620553b53b08ec75b40d6580ccdf11" name="gacf620553b53b08ec75b40d6580ccdf11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf620553b53b08ec75b40d6580ccdf11">&#9670;&#160;</a></span>pcf_I2c_slaveWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_slaveWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Buffer_t *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcf_size_t *const&#160;</td>
          <td class="paramname"><em>actual_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a slave write operation on the I2C bus. </p>
<p>The slave can call this function once it receives a request from master to transmit data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">buffer</td><td>[IN] - Pointer to data buffer </td></tr>
    <tr><td class="paramname">actual_size</td><td>[OUT] - Pointer to pcf_size_t, stores the total number of bytes actually written </td></tr>
  </table>
  </dd>
</dl>
<p>(Optional parameter, pass PCF_NULL if not required.)</p>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>data</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid or buffer.length is 0. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab862e0b636c160d768365e9ba1f97800" name="gab862e0b636c160d768365e9ba1f97800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab862e0b636c160d768365e9ba1f97800">&#9670;&#160;</a></span>pcf_I2c_slaveReceivedRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_slaveReceivedRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#gac449d24faad23209d50113c27a6e01e1">EnI2cSlaveRequestType_t</a> *const&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the type of the request received by slave from the master. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">type</td><td>[OUT] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#gac449d24faad23209d50113c27a6e01e1" title="I2C slave request type.">EnI2cSlaveRequestType_t</a>, stores the type of the received request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>type</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf92e2cabb6c31c4b7c123b469ceb9e53" name="gaf92e2cabb6c31c4b7c123b469ceb9e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf92e2cabb6c31c4b7c123b469ceb9e53">&#9670;&#160;</a></span>pcf_I2c_isBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_isBusy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnPCFBoolean_t *const&#160;</td>
          <td class="paramname"><em>isBusy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the i2c bus is busy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">isBusy</td><td>[OUT] - Pointer to EnPCFBoolean_t, stores the i2c state, is set to enPCFBoolean_True if i2c is busy else set to enPCFBoolean_False. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>isBusy</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga082c04b9ee95ad97a377647fa576807a" name="ga082c04b9ee95ad97a377647fa576807a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga082c04b9ee95ad97a377647fa576807a">&#9670;&#160;</a></span>pcf_I2c_getRxDataAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_getRxDataAvailable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcf_size_t *const&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of bytes received in i2c receive buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">count</td><td>[OUT] - Pointer to pcf_size_t, stores the number of bytes available for read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>count</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga25d93848553469264f26d4a8b4195094" name="ga25d93848553469264f26d4a8b4195094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25d93848553469264f26d4a8b4195094">&#9670;&#160;</a></span>pcf_I2c_rxBufferFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_rxBufferFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush I2c rx buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_OPERATION : The receive buffer is PCF_NULL. <br  />
 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa22722773b41444ba2128da7cd35333f" name="gaa22722773b41444ba2128da7cd35333f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa22722773b41444ba2128da7cd35333f">&#9670;&#160;</a></span>pcf_I2c_txBufferFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_txBufferFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush I2c tx buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_OPERATION : The transmit buffer is PCF_NULL. <br  />
 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad5524b9c476b70008fa3b79012597304" name="gad5524b9c476b70008fa3b79012597304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5524b9c476b70008fa3b79012597304">&#9670;&#160;</a></span>pcf_I2c_getId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_getId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcf_size_t *const&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <em>id</em>  of given I2c object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">id</td><td>[OUT] - Pointer to pcf_size_t, stores the id of given I2c. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>id</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga141b8a97b1079ca81a5de159a334ae45" name="ga141b8a97b1079ca81a5de159a334ae45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga141b8a97b1079ca81a5de159a334ae45">&#9670;&#160;</a></span>pcf_I2c_getBaudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_getBaudrate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_frequency__t.html">Frequency_t</a> *const&#160;</td>
          <td class="paramname"><em>baud_rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the baudrate set for I2c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">baud_rate</td><td>[OUT] - Pointer to <a class="el" href="struct_frequency__t.html" title="MCU frequency struct.">Frequency_t</a>, stores the baudrate set for I2c. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>baud_rate</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6ec7f1ee6d132db8d39ea3044b1bc447" name="ga6ec7f1ee6d132db8d39ea3044b1bc447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ec7f1ee6d132db8d39ea3044b1bc447">&#9670;&#160;</a></span>pcf_I2c_getAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_getAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the own address set for I2c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">address</td><td>[OUT] - Pointer to uint16_t, stores the address set for I2c. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>address</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1cf25d28290bf27133269753f8fc62d6" name="ga1cf25d28290bf27133269753f8fc62d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cf25d28290bf27133269753f8fc62d6">&#9670;&#160;</a></span>pcf_I2c_getAddressMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_getAddressMask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>address_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the own address mask set for I2c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">address_mask</td><td>[OUT] - Pointer to uint16_t, stores the address_mask set for I2c. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>address_mask</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga559ac4b618aec28688ff479e0f86ff53" name="ga559ac4b618aec28688ff479e0f86ff53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga559ac4b618aec28688ff479e0f86ff53">&#9670;&#160;</a></span>pcf_I2c_isGeneralCallEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_isGeneralCallEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnPCFBoolean_t *const&#160;</td>
          <td class="paramname"><em>isEnabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if GeneralCall is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">isEnabled</td><td>[OUT] - Pointer to EnPCFBoolean_t, stores the state of gerneral call, is set to enPCFBoolean_True if general call is enable else set to enPCFBoolean_False. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>isEnabled</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga775a4e80f922e06d110b5783a3616e50" name="ga775a4e80f922e06d110b5783a3616e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga775a4e80f922e06d110b5783a3616e50">&#9670;&#160;</a></span>pcf_I2c_getRxBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_getRxBufferSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcf_size_t *const&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of I2c receive buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">size</td><td>[OUT] - Pointer to pcf_size_t, stores the size of I2c receive buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>size</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga22091654e56ea13f98a12b2548945132" name="ga22091654e56ea13f98a12b2548945132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22091654e56ea13f98a12b2548945132">&#9670;&#160;</a></span>pcf_I2c_getTxBufferSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_getTxBufferSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcf_size_t *const&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of I2c transmit buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I2c</td><td>[IN] - Pointer to <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea" title="I2C Entity object.">I2c_t</a> entity object. </td></tr>
    <tr><td class="paramname">size</td><td>[OUT] - Pointer to pcf_size_t, stores the size of I2c transmit buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_SUCCESS : On success. </li>
<li>
PCF_S_NULL_ARG : <em>i2c</em>  or <em>size</em>  is PCF_NULL. (Checked only in debug mode) </li>
<li>
PCF_S_INVALID_ARG : <em>i2c</em>  is invalid. (Checked only in debug mode) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab9aa76cde12a0f4d83e4b8dedfc80116" name="gab9aa76cde12a0f4d83e4b8dedfc80116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9aa76cde12a0f4d83e4b8dedfc80116">&#9670;&#160;</a></span>pcf_I2c_customCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCF_MCAL_API pcf_status_t pcf_I2c_customCommand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga8fd8e4fab7d6b537d91df518e7d3aeea">I2c_t</a> *const&#160;</td>
          <td class="paramname"><em>I2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pcf_command_t&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcf_generic_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can be used to extend the functionality provided by the I2C package item. </p>
<dl class="section note"><dt>Note</dt><dd>Refer to platform specific implementation header file (if they exists) under pcf/peripherals/i2c/&lt;platform specific path&gt;/commands for more details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>- Pointer to I2c entity object </td></tr>
    <tr><td class="paramname">command</td><td>- The custom command to send. </td></tr>
    <tr><td class="paramname">data</td><td>- The data associated with the custom command. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pcf_status_t Valid values : <ul>
<li>
PCF_S_NOT_IMPLEMENTED : The function is not implemented. </li>
</ul>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga529397d7a798fee26f1872ec238f0041" name="ga529397d7a798fee26f1872ec238f0041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga529397d7a798fee26f1872ec238f0041">&#9670;&#160;</a></span>id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2cConfig_t::id</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2c Id. Refer to native defs.h file for appropriate i2c id </p>

</div>
</div>
<a id="gab9112274d274b9da9211e70f7a500fc1" name="gab9112274d274b9da9211e70f7a500fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9112274d274b9da9211e70f7a500fc1">&#9670;&#160;</a></span>baudrate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2cConfig_t::baudrate</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clock speed for i2c communication in Hz. The actual value set may be different from the value provided by user </p>

</div>
</div>
<a id="ga2bbace4037550379597e998a7f582529" name="ga2bbace4037550379597e998a7f582529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bbace4037550379597e998a7f582529">&#9670;&#160;</a></span>addressType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__pcf__mcal__peripherals__i2c.html#ga4dc94555d8d00ba1f70bc4caeec91d88">EnI2cAddressType_t</a> I2cConfig_t::addressType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2c address type </p>

</div>
</div>
<a id="ga0ac759f54ef1325767a83a9bbdbed790" name="ga0ac759f54ef1325767a83a9bbdbed790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ac759f54ef1325767a83a9bbdbed790">&#9670;&#160;</a></span>ownAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t I2cConfig_t::ownAddress</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2c address. It is used to filter packets on the I2c bus. For example: To configure own address as 5 and using 7bit addressing. Set addressType as enI2cAddress_7bit and value = 0x0005. </p>

</div>
</div>
<a id="ga3785e7bc0bf5e4b4181c5df242e3d702" name="ga3785e7bc0bf5e4b4181c5df242e3d702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3785e7bc0bf5e4b4181c5df242e3d702">&#9670;&#160;</a></span>ownAddressMask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t I2cConfig_t::ownAddressMask</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2c device address mask. Bits in the mask value set as 1 will not be taken into account in determining an address match. For example: Consider a device with address = 0x0005. Now, if ownAddressMask is set to 0x0001 for the device, then it will respond to address value 0x0004 and 0x0005. </p>

</div>
</div>
<a id="gafaebbfc2e6dfa1c3ee12df6d458d2f7e" name="gafaebbfc2e6dfa1c3ee12df6d458d2f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaebbfc2e6dfa1c3ee12df6d458d2f7e">&#9670;&#160;</a></span>generalCallEnable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EnPCFBoolean_t I2cConfig_t::generalCallEnable</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies to enable general call or not. Messages with address 0x00 will be received. This parameter is used when using device in slave mode. </p>

</div>
</div>
<a id="gafe7f46a24307e2f158bc087f2082311b" name="gafe7f46a24307e2f158bc087f2082311b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe7f46a24307e2f158bc087f2082311b">&#9670;&#160;</a></span>txBufferSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcf_size_t I2cConfig_t::txBufferSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies transmit buffer size in bytes. If size is 0 then write will happen in polling/blocking mode </p>

</div>
</div>
<a id="gae80263dd6717b8b5a43094f5d8f56e7a" name="gae80263dd6717b8b5a43094f5d8f56e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae80263dd6717b8b5a43094f5d8f56e7a">&#9670;&#160;</a></span>rxBufferSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcf_size_t I2cConfig_t::rxBufferSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies receive buffer size in bytes Value should be greater than 0. if it is zero default value 1 will be set. </p>

</div>
</div>
<a id="ga3c0e1653d9895946855bcb907db0a252" name="ga3c0e1653d9895946855bcb907db0a252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c0e1653d9895946855bcb907db0a252">&#9670;&#160;</a></span>hardwareCfg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pcf_generic_t I2cConfig_t::hardwareCfg</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hardware platform specific configuration. Refer to native types.h file </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
